import numpy as np
from scipy.stats import norm

def simulate_gbm_paths(S0, r, sigma, T, N, M, scheme="euler", antithetic=False, seed=0):
    """
    This function generates Geometric Brownian Motion (GBM) paths.

    Args:
        S0 (float):             The starting point of the paths.
        r (float):              The 'percentage drift' constant of the GBM (risk-free interest rate).
        sigma (float):          The 'percentage volatility' constant of the GBM.
        T (float):              The expiry time of the paths -- the maturity time of the asset.
        N (int):                The number of time steps to be simulated.
        M (int):                The number of paths to be simulated.
        scheme (str, optional): The scheme used to solve the SDE. Default is "euler". Alternative is "milstein".
        method (str, optional): The method used to generate the path ensemble. Default is "standard". Alternative is "antithetic".
        seed (int, optional):             The seed of the random number generator.

    Returns:
        paths:                  The GBM paths generated by the algorithm.
    
    Raises:
        ValueError:             Raises an Error if an invalid scheme is passed to the function.
    """
    rng = np.random.default_rng(seed)
    dt = T / N
    paths = np.empty((M, N+1), dtype=float)
    paths[:, 0] = S0
    for n in range(N):
        if antithetic:
            M1 = (M+1)//2
            z1 = rng.standard_normal(M1)
            z2 = -z1[:(M-M1)]
            z = np.append(z1,z2)
        else:
            z = rng.standard_normal(M)
        
        dW = np.sqrt(dt) * z
        S = paths[:, n]
        if scheme == "euler":
            paths[:, n+1] = S + r*S*dt + sigma*S*dW
        elif scheme == "milstein":
            paths[:, n+1] = S + r*S*dt + sigma*S*dW + 0.5*(sigma**2)*S*(dW**2 - dt)
        else:
            raise ValueError("'scheme' must be 'euler' or 'milstein'")
    return paths

def price_euro_mc(S0, K, r, sigma, T, N, M, scheme="euler", antithetic=False, seed=0):
    """
    This function returns the Option Price MC estimates of the European's Call and Put options.

    Args:
        S0 (float):             The starting point of the paths (current asset price).
        K (float):              The Strike price.
        r (float):              The 'percentage drift' constant of the GBM (risk-free interest rate).
        sigma (float):          The 'percentage volatility' constant of the GBM.
        T (float):              The expiry time of the paths -- the maturity time of the asset.
        N (int):                The number of time steps to be simulated.
        M (int):                The number of paths to be simulated.
        scheme (str, optional): The scheme used to solve the SDE. Default is "euler". Alternative is "milstein".
        seed (int,optional):    The seed of the random number generator.

    Returns:
        pv_call (array):        The Option Price MC estimate of the European's call price.
        pv_put (array):         The Option Price MC estimate of the European's put price.
    
    Raises:
        ValueError:             Raises an Error if an invalid scheme is passed.
    """
    # Simulate GBM paths using MC algorithm
    paths = simulate_gbm_paths(S0, r, sigma, T, N, M, scheme=scheme, antithetic=antithetic, seed=0)
    # Get the Future Simulated Price of each path
    ST = paths[:, -1] 
    # Evaluate the payoff of call and put options
    payoff_call = np.maximum(ST - K, 0.0)
    payoff_put = np.maximum(K- ST, 0.0)
    # Discount back to the present value
    disc = np.exp(-r*T) 
    pv_call = disc * payoff_call
    pv_put = disc * payoff_put

    est_call  = pv_call.mean()
    est_put   = pv_put.mean()
    var_call  = (disc**2) * pv_call.var(ddof=1) / len(pv_call)
    var_put   = (disc**2) * pv_put.var(ddof=1) / len(pv_put)
    se_call   = np.sqrt(var_call)
    se_put    = np.sqrt(var_put)

    ci95_call = (est_call - 1.96*se_call, est_call + 1.96*se_call)
    ci95_put = (est_put - 1.96*se_put, est_put + 1.96*se_put)

    return {"price_call": est_call, "se_call": se_call, "ci95_call": ci95_call, "price_put": est_put, "se_put": se_put, "ci95_put": ci95_put}